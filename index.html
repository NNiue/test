<!DOCTYPE html>
<html>
<head>
<title>LoRA生成器 - 2025新版</title>
<style>
/* 保留所有原始CSS样式不变 */
body { font-family: Arial; max-width: 800px; margin: 20px auto; padding: 20px; }
input, select, textarea { display: block; margin: 10px 0; width: 100%; padding: 8px; }
button { background: #007bff; color: white; border: none; padding: 10px 20px; cursor: pointer; }
#results img { width: 256px; margin: 10px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
#status { color: #d9534f; margin: 10px 0; }
</style>
</head>
<body>
<h2>LoRA图片生成器（HuggingFace适配版）</h2>
<input type="file" id="imageInput" accept="image/*">
<select id="modelSelect">
<option value="NNiuNUll/my-lora">赛博风格增强模型 v1</option>
</select>
<input type="number" id="num" value="1" min="1" max="4">
<textarea id="prompt" placeholder="示例：赛博朋克风格的未来城市，霓虹灯光，雨夜氛围"></textarea>
<button onclick="generate()">生成图片</button>
<div id="status"></div>
<div id="results"></div>

<script>
// ==== 修复版核心逻辑 ====
const HF_API_TOKEN = "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";
const API_ENDPOINT = "https://api-inference.huggingface.co/models/NNiuNUll/my-lora";

async function generate() {
  const btn = document.querySelector('button');
  btn.disabled  = true;
  document.getElementById('status').textContent  = "正在生成...";

  try {
    // 验证输入完整性
    const file = document.getElementById('imageInput').files[0];
    if (!file) throw new Error("请先上传参考图！");

    // 转换图片为Base64
    const imageBase64 = await readFileAsBase64(file);

    // 构建标准JSON请求体
    const payload = {
      inputs: document.getElementById('prompt').value,
      parameters: {
        num_outputs: parseInt(document.getElementById('num').value),
        lora_scale: 0.8,
        image: imageBase64,
        height: 1024,
        width: 1024
      }
    };

    // 添加模型加载重试机制
    let retryCount = 0;
    let response;
    do {
      response = await fetch(API_ENDPOINT, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${HF_API_TOKEN}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });

      if (response.status  === 503) {
        const waitTime = 30; // 默认等待30秒
        await new Promise(resolve => setTimeout(resolve, waitTime * 1000));
        retryCount++;
      } else {
        break;
      }
    } while (retryCount < 3);

    // 兼容性错误处理
    if (!response.ok)  {
      const errorText = await response.text();
      throw new Error(`API错误[${response.status}]:  ${parseHuggingFaceError(errorText)}`);
    }

    // 解析二进制图像响应
    const blob = await response.blob();
    const imgNode = document.createElement('img');
    imgNode.src  = URL.createObjectURL(blob);
    document.getElementById('results').appendChild(imgNode);

    document.getElementById('status').textContent  = "生成成功！";

  } catch (error) {
    document.getElementById('status').textContent  = `错误: ${error.message.replace('API 错误: ', '')}`;
    console.error(" 调试日志:", error);
  } finally {
    btn.disabled  = false;
  }
}

// ===== 工具函数 =====
function readFileAsBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload  = () => resolve(reader.result.split(',')[1]);  // 提取Base64数据部分
    reader.onerror  = error => reject(error);
    reader.readAsDataURL(file);
  });
}

function parseHuggingFaceError(text) {
  try {
    const htmlDoc = new DOMParser().parseFromString(text, "text/html");
    return htmlDoc.querySelector('p').textContent  || "未知错误";
  } catch {
    return text.slice(0,  100);
  }
}
</script>
</body>
</html>